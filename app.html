<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VoiceCal</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>

<style>
body {
  font-family: Arial, sans-serif;
  text-align: center;
  padding: 40px;
  background: #f4f4f4;
}

h1 {
  font-size: 32px;
}

button {
  font-size: 18px;
  padding: 15px 25px;
  margin: 15px;
  cursor: pointer;
  border-radius: 8px;
  border: none;
  background: #4285F4;
  color: white;
}

button:hover {
  background: #3367D6;
}

#status {
  margin-top: 20px;
  font-size: 18px;
  min-height: 24px;
}

.version {
  margin-top: 40px;
  font-size: 14px;
  color: #888;
}
</style>
</head>

<body>

<h1>ðŸŽ¤ VoiceCal</h1>

<button onclick="startListening()">Start Listening</button>

<div id="status">Ready</div>

<div class="version">Version 6.6</div>

<script>
const CLIENT_ID = "YOUR_CLIENT_ID_HERE";
const API_KEY = "YOUR_API_KEY_HERE";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

let tokenClient;
let pendingEvent = null;

function setStatus(msg) {
  document.getElementById("status").innerText = msg;
}

function gapiLoaded() {
  gapi.load("client", async () => {
    await gapi.client.init({
      apiKey: API_KEY,
      discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
    });
  });
}

function gisLoaded() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: async (response) => {
      if (response.error) {
        setStatus("Auth Error");
        return;
      }
      await createEvent();
    },
  });
}

window.onload = () => {
  gapiLoaded();
  gisLoaded();
};

function startListening() {
  if (!("webkitSpeechRecognition" in window)) {
    alert("Speech recognition not supported in this browser.");
    return;
  }

  const recognition = new webkitSpeechRecognition();
  recognition.lang = "en-US";
  recognition.interimResults = false;

  recognition.onstart = () => setStatus("Listening...");
  recognition.onerror = (e) => setStatus("Mic error: " + e.error);

  recognition.onresult = (event) => {
    const text = event.results[0][0].transcript;
    setStatus("Heard: " + text);
    parseText(text);
  };

  recognition.start();
}

function parseText(text) {

  let date = new Date();
  const originalText = text.trim();
  const lower = originalText.toLowerCase();

  const mealWords = ["breakfast", "lunch", "dinner", "snack"];
  const detectedMeal = mealWords.find(word => lower.startsWith(word));

  const timeRegex = /(\d{1,2})(?::(\d{2}))?\s*(a\.?m\.?|p\.?m\.?)/i;
  const match = lower.match(timeRegex);

  if (match) {
    let hour = parseInt(match[1]);
    let minute = match[2] ? parseInt(match[2]) : 0;
    let period = match[3].toLowerCase();

    if (period.includes("p") && hour !== 12) hour += 12;
    if (period.includes("a") && hour === 12) hour = 0;

    date.setHours(hour, minute, 0, 0);
  }

  // âœ… DEFAULT 30 MINUTES NOW
  const end = new Date(date.getTime() + 30 * 60 * 1000);

  let cleanTitle = originalText.replace(timeRegex, "").trim();

  if (detectedMeal) {
    const withoutMealWord = cleanTitle.substring(detectedMeal.length).trim();
    cleanTitle = detectedMeal.toUpperCase() + ": " + withoutMealWord;
  }

  let eventData = {
    summary: cleanTitle,
    start: { dateTime: date.toISOString() },
    end: { dateTime: end.toISOString() }
  };

  if (detectedMeal) {
    eventData.reminders = {
      useDefault: false,
      overrides: []
    };
  }

  pendingEvent = eventData;

  setStatus("Authenticating...");
  tokenClient.requestAccessToken({
    prompt: gapi.client.getToken() ? "" : "consent"
  });
}

async function createEvent() {
  if (!pendingEvent) return;

  try {
    await gapi.client.calendar.events.insert({
      calendarId: "primary",
      resource: pendingEvent
    });

    setStatus("Event Created âœ”");
  } catch (error) {
    setStatus("Error creating event");
  }
}
</script>

</body>
</html>
