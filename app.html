<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>VoiceCal v10</title>

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>

<style>
body{
  margin:0;
  background:#000;
  color:#fff;
  font-family:Arial, sans-serif;
  display:flex;
  flex-direction:column;
  height:100vh;
}

header{
  text-align:center;
  padding:20px 0;
  font-size:20px;
}

main{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;
  padding-top:140px;
}

#ring{
  width:160px;
  height:160px;
  border-radius:50%;
  border:8px solid transparent;
  transition:0.3s ease;
}

#ring.active{
  border:8px solid red;
  box-shadow:0 0 40px red;
}

#status{
  margin-top:30px;
  opacity:0.9;
  font-size:18px;
}

#card{
  background:#111;
  margin:0 auto 40px auto;
  padding:20px;
  border-radius:12px;
  width:85%;
  max-width:420px;
  display:none;
  text-align:center;
}
</style>
</head>

<body>

<header>VoiceCal v10</header>

<main>
  <div id="ring"></div>
  <div id="status">Starting...</div>
</main>

<div id="card"></div>

<script>

const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

let tokenClient;
let pendingEvent = null;
let mode = "command";

let waitingForTime = false;
let pendingTitle = "";
let pendingDateOffset = 0;

const ring = document.getElementById("ring");
const statusDiv = document.getElementById("status");
const cardDiv = document.getElementById("card");

const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
recognition.lang = "en-US";
recognition.interimResults = false;
recognition.continuous = false;

/* ---------- AUTO START ---------- */

window.onload = () => {
  setTimeout(startListening, 800);
};

function startListening(){
  statusDiv.innerText = "Listening...";
  recognition.start();
}

/* ---------- SPEECH EVENTS ---------- */

recognition.onstart = () => ring.classList.add("active");

recognition.onend = () => {
  ring.classList.remove("active");

  // Auto-restart unless confirming
  if(mode === "command" && !waitingForTime){
    setTimeout(startListening, 1000);
  }
};

recognition.onerror = () => {
  statusDiv.innerText = "Mic error. Retrying...";
  setTimeout(startListening, 1500);
};

recognition.onresult = (event) => {
  const text = event.results[0][0].transcript.toLowerCase().trim();
  console.log("Transcript:", text);

  if(waitingForTime){
    const timeData = extractTime(text);

    if(!timeData){
      statusDiv.innerText = "Please say a time like 6pm.";
      return;
    }

    waitingForTime = false;
    createEventFromData(pendingTitle, timeData, pendingDateOffset);
    return;
  }

  if(mode === "command") handleCommand(text);
  else handleConfirmation(text);
};

/* ---------- TIME PARSER ---------- */

function extractTime(text){

  text = text
    .replace(/\./g,"")
    .replace(/\s+/g," ")
    .replace(/\bnoon\b/g,"12 pm")
    .replace(/\bmidnight\b/g,"12 am")
    .replace(/\bp\s*m\b/g,"pm")
    .replace(/\ba\s*m\b/g,"am");

  const wordToNumber = {
    one:1,two:2,three:3,four:4,five:5,
    six:6,seven:7,eight:8,nine:9,ten:10,
    eleven:11,twelve:12
  };

  let numeric = text.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/);
  if(numeric){
    return {
      hour: parseInt(numeric[1]),
      minute: numeric[2] ? parseInt(numeric[2]) : 0,
      meridian: numeric[3]
    };
  }

  let spoken = text.match(/\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)\b\s*(am|pm)?/);
  if(spoken){
    return {
      hour: wordToNumber[spoken[1]],
      minute: 0,
      meridian: spoken[2] || "pm"
    };
  }

  let bare = text.match(/\bat\s*(\d{1,2})\b/);
  if(bare){
    return {
      hour: parseInt(bare[1]),
      minute: 0,
      meridian: "pm"
    };
  }

  return null;
}

/* ---------- COMMAND ---------- */

function handleCommand(text){

  const timeData = extractTime(text);
  const hasTomorrow = text.includes("tomorrow");

  if(!timeData){
    if(hasTomorrow){
      waitingForTime = true;
      pendingTitle = text.replace("tomorrow","").trim();
      pendingDateOffset = 1;
      statusDiv.innerText = "What time tomorrow?";
      return;
    }

    statusDiv.innerText = "Please include a time like 3pm.";
    return;
  }

  createEventFromData(text, timeData, hasTomorrow ? 1 : 0);
}

/* ---------- CREATE EVENT ---------- */

function createEventFromData(titleText, timeData, dayOffset){

  const date = new Date();
  date.setDate(date.getDate() + dayOffset);

  let hour = timeData.hour;
  if(timeData.meridian === "pm" && hour !== 12) hour += 12;
  if(timeData.meridian === "am" && hour === 12) hour = 0;

  date.setHours(hour, timeData.minute, 0);

  const end = new Date(date.getTime() + 60*60*1000);

  const cleanTitle = titleText.replace(/at.*$/,"").replace("tomorrow","").trim() || "VoiceCal Event";

  pendingEvent = {
    summary: cleanTitle,
    start: {
      dateTime: date.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    end: {
      dateTime: end.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    reminders: {
      useDefault: false,
      overrides: [
        { method: "popup", minutes: 30 }
      ]
    }
  };

  showConfirmation();
}

/* ---------- CONFIRM ---------- */

function showConfirmation(){
  mode = "confirm";
  cardDiv.style.display = "block";

  const readable = new Date(pendingEvent.start.dateTime).toLocaleString();

  cardDiv.innerHTML = `
    <b>Create Event?</b><br><br>
    ${pendingEvent.summary}<br>
    ${readable}<br><br>
    Say "yes" or "no"
  `;

  statusDiv.innerText = "Waiting for confirmation...";
  setTimeout(() => recognition.start(), 600);
}

function handleConfirmation(text){
  if(text.includes("yes")){
    statusDiv.innerText = "Authorizing...";
    authorize();
  } else {
    resetToListening();
  }
}

function resetToListening(){
  cardDiv.style.display = "none";
  mode = "command";
  setTimeout(startListening, 800);
}

/* ---------- GOOGLE AUTH ---------- */

function authorize(){

  gapi.load("client", async () => {

    await gapi.client.init({
      discoveryDocs:["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"]
    });

    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: async (resp) => {
        if(resp.error){
          statusDiv.innerText = "Authorization failed.";
          resetToListening();
          return;
        }
        gapi.client.setToken(resp);
        await createEvent();
      }
    });

    tokenClient.requestAccessToken();
  });
}

async function createEvent(){

  await gapi.client.calendar.events.insert({
    calendarId: "primary",
    resource: pendingEvent
  });

  statusDiv.innerText = "Event created!";
  resetToListening();
}

</script>

</body>
</html>
