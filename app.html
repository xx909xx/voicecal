<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>VoiceCal</title>

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>

<style>
body{
  margin:0;
  background:#000;
  color:#fff;
  font-family:Arial, sans-serif;
  display:flex;
  flex-direction:column;
  height:100vh;
}
header{
  text-align:center;
  padding:20px 0;
  font-size:20px;
}
main{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
  padding-top:140px;
}
#ring{
  width:160px;
  height:160px;
  border-radius:50%;
  border:8px solid transparent;
  transition:0.3s ease;
}
#ring.active{
  border:8px solid red;
  box-shadow:0 0 40px red;
}
#status{
  margin-top:30px;
  font-size:18px;
}
#card{
  background:#111;
  margin:0 auto 40px;
  padding:20px;
  border-radius:12px;
  width:85%;
  max-width:420px;
  display:none;
  text-align:center;
}
footer{
  text-align:center;
  font-size:12px;
  opacity:0.5;
  padding:10px;
}
</style>
</head>

<body>

<header>VoiceCal</header>

<main>
  <div id="ring"></div>
  <div id="status">Starting…</div>
</main>

<div id="card"></div>

<footer>VoiceCal v8.8.2</footer>

<script>
/* ---------- CONFIG ---------- */
const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

/* ---------- STATE ---------- */
let recognition;
let recognitionReady = false;
let isListening = false;

let mode = "command";
let waitingForTime = false;

let pendingTitle = "";
let pendingDate = null;
let pendingEvent = null;

/* ---------- ELEMENTS ---------- */
const ring = document.getElementById("ring");
const statusDiv = document.getElementById("status");
const cardDiv = document.getElementById("card");

/* ---------- INIT ---------- */
window.onload = () => {
  initRecognition();
  setTimeout(startListening, 800);
};

/* ---------- SPEECH ---------- */
function initRecognition(){
  if(recognitionReady) return;

  recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  recognition.lang = "en-US";
  recognition.continuous = false;
  recognition.interimResults = false;

  recognition.onstart = () => {
    ring.classList.add("active");
    statusDiv.innerText = "Listening…";
  };

  recognition.onend = () => {
    ring.classList.remove("active");
    isListening = false;

    if(mode !== "confirm"){
      setTimeout(startListening, 150);
    }
  };

  recognition.onerror = () => {
    isListening = false;
    setTimeout(startListening, 200);
  };

  recognition.onresult = (event) => {
    const text = event.results[0][0].transcript.toLowerCase().trim();

    if(waitingForTime){
      const timeData = extractTime(text);
      if(!timeData){
        statusDiv.innerText = "Please say a time like 6pm.";
        return;
      }
      waitingForTime = false;
      buildEvent(pendingTitle, timeData, pendingDate);
      return;
    }

    if(mode === "command") handleCommand(text);
    else handleConfirmation(text);
  };

  recognitionReady = true;
}

function startListening(){
  if(isListening || !recognitionReady) return;
  try{
    isListening = true;
    recognition.start();
  }catch(e){
    isListening = false;
  }
}

/* ---------- DATE + TIME ---------- */
const weekdays = ["sunday","monday","tuesday","wednesday","thursday","friday","saturday"];

function resolveDate(text){
  const now = new Date();
  for(let i=0;i<7;i++){
    if(text.includes(weekdays[i])){
      let d = new Date(now);
      let diff = (i - d.getDay() + 7) % 7;
      if(diff === 0) diff = 7;
      d.setDate(d.getDate() + diff);
      return d;
    }
  }
  if(text.includes("tomorrow")){
    let d = new Date(now);
    d.setDate(d.getDate() + 1);
    return d;
  }
  return new Date(now);
}

function extractTime(text){
  text = text
    .replace(/\./g,"")
    .replace(/\bnoon\b/g,"12 pm")
    .replace(/\bmidnight\b/g,"12 am");

  const m = text.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/);
  if(!m) return null;

  return { h:+m[1], min:+(m[2]||0), mer:m[3] };
}

/* ---------- COMMAND ---------- */
function handleCommand(text){
  const t = extractTime(text);
  const d = resolveDate(text);

  if(!t){
    waitingForTime = true;
    pendingTitle = text;
    pendingDate = d;
    statusDiv.innerText = "What time?";
    return;
  }
  buildEvent(text, t, d);
}

/* ---------- EVENT ---------- */
function buildEvent(titleText, timeData, date){
  let h = timeData.h;
  if(timeData.mer === "pm" && h !== 12) h += 12;
  if(timeData.mer === "am" && h === 12) h = 0;

  date.setHours(h, timeData.min, 0, 0);
  const end = new Date(date.getTime() + 60 * 60 * 1000);

  const cleanTitle = titleText
    .replace(/\b(monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/g,"")
    .replace(/\b(at\s*\d.*$)/,"")
    .trim() || "VoiceCal Event";

  pendingEvent = {
    summary: cleanTitle,
    start: {
      dateTime: date.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    end: {
      dateTime: end.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    reminders:{
      useDefault:false,
      overrides:[
        { method:"popup", minutes:30 },
        { method:"popup", minutes:1 }
      ]
    }
  };

  showConfirmation();
}

/* ---------- CONFIRM ---------- */
function showConfirmation(){
  mode = "confirm";
  cardDiv.style.display = "block";

  cardDiv.innerHTML = `
    <b>Create Event?</b><br><br>
    ${pendingEvent.summary}<br>
    ${new Date(pendingEvent.start.dateTime).toLocaleString()}<br><br>
    Say "yes" or "no"
  `;

  statusDiv.innerText = "Waiting for confirmation…";
  setTimeout(startListening, 500);
}

function handleConfirmation(text){
  if(text.includes("yes")){
    statusDiv.innerText = "Authorizing…";
    authorize();
  }else{
    reset();
  }
}

function reset(){
  cardDiv.style.display = "none";
  mode = "command";
  waitingForTime = false;
  setTimeout(startListening, 300);
}

/* ---------- GOOGLE ---------- */
function authorize(){
  gapi.load("client", async () => {
    await gapi.client.init({
      discoveryDocs:[
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"
      ]
    });

    const tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: async (resp) => {
        if(resp.error){
          statusDiv.innerText = "Authorization failed.";
          reset();
          return;
        }
        gapi.client.setToken(resp);
        await createEvent();
      }
    });

    tokenClient.requestAccessToken();
  });
}

async function createEvent(){
  try{
    await gapi.client.calendar.events.insert({
      calendarId:"primary",
      resource: pendingEvent
    });
    statusDiv.innerText = "Event created!";
  }catch(e){
    statusDiv.innerText = "Calendar error.";
  }
  reset();
}
</script>

</body>
</html>
