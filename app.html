<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>VoiceCal</title>

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>

<style>
body{
  margin:0;
  background:#000;
  color:#fff;
  font-family:Arial, sans-serif;
  display:flex;
  flex-direction:column;
  height:100vh;
}

header{
  text-align:center;
  padding:20px 0;
  font-size:20px;
}

main{
  flex:1;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;
  padding-top:140px;
}

#ring{
  width:160px;
  height:160px;
  border-radius:50%;
  border:8px solid transparent;
  transition:0.3s ease;
}

#ring.active{
  border:8px solid red;
  box-shadow:0 0 40px red;
}

#status{
  margin-top:30px;
  opacity:0.9;
  font-size:18px;
}

#card{
  background:#111;
  margin:0 auto 40px auto;
  padding:20px;
  border-radius:12px;
  width:85%;
  max-width:420px;
  display:none;
  text-align:center;
}
</style>
</head>

<body>

<header>VoiceCal</header>

<main>
  <div id="ring"></div>
  <div id="status">Starting…</div>
</main>

<div id="card"></div>

<script>
/* ---------- CONFIG ---------- */

const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

/* ---------- STATE ---------- */

let recognition;
let isListening = false;

let mode = "command";
let waitingForTime = false;

let pendingTitle = "";
let pendingDateOffset = 0;
let pendingEvent = null;

/* ---------- ELEMENTS ---------- */

const ring = document.getElementById("ring");
const statusDiv = document.getElementById("status");
const cardDiv = document.getElementById("card");

/* ---------- INIT ---------- */

window.onload = () => {
  setTimeout(startListening, 800);
};

/* ---------- SPEECH SETUP ---------- */

function createRecognition(){
  recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  recognition.lang = "en-US";
  recognition.interimResults = false;
  recognition.continuous = false;

  recognition.onstart = () => {
    ring.classList.add("active");
  };

  recognition.onend = () => {
    ring.classList.remove("active");
    isListening = false;

    if(mode !== "confirm"){
      setTimeout(startListening, 900);
    }
  };

  recognition.onerror = () => {
    isListening = false;
    setTimeout(startListening, 1200);
  };

  recognition.onresult = (event) => {
    const text = event.results[0][0].transcript.toLowerCase().trim();

    if(waitingForTime){
      const timeData = extractTime(text);
      if(!timeData){
        statusDiv.innerText = "Please say a time like 6pm.";
        return;
      }
      waitingForTime = false;
      createEventFromData(pendingTitle, timeData, pendingDateOffset);
      return;
    }

    if(mode === "command") handleCommand(text);
    else handleConfirmation(text);
  };
}

function startListening(){
  if(isListening) return;

  isListening = true;
  statusDiv.innerText = "Listening…";
  createRecognition();
  recognition.start();
}

/* ---------- TIME PARSER ---------- */

function extractTime(text){
  text = text
    .replace(/\./g,"")
    .replace(/\s+/g," ")
    .replace(/\bnoon\b/g,"12 pm")
    .replace(/\bmidnight\b/g,"12 am")
    .replace(/\bp\s*m\b/g,"pm")
    .replace(/\ba\s*m\b/g,"am");

  const wordToNumber = {
    one:1,two:2,three:3,four:4,five:5,
    six:6,seven:7,eight:8,nine:9,ten:10,
    eleven:11,twelve:12
  };

  let numeric = text.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/);
  if(numeric){
    return {
      hour: parseInt(numeric[1]),
      minute: numeric[2] ? parseInt(numeric[2]) : 0,
      meridian: numeric[3]
    };
  }

  let spoken = text.match(/\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)\b\s*(am|pm)?/);
  if(spoken){
    return {
      hour: wordToNumber[spoken[1]],
      minute: 0,
      meridian: spoken[2] || "pm"
    };
  }

  return null;
}

/* ---------- COMMAND HANDLING ---------- */

function handleCommand(text){
  const timeData = extractTime(text);
  const hasTomorrow = text.includes("tomorrow");

  if(!timeData){
    if(hasTomorrow){
      waitingForTime = true;
      pendingTitle = text.replace("tomorrow","").trim();
      pendingDateOffset = 1;
      statusDiv.innerText = "What time tomorrow?";
      return;
    }

    statusDiv.innerText = "Please include a time like 3pm.";
    return;
  }

  createEventFromData(text, timeData, hasTomorrow ? 1 : 0);
}

/* ---------- EVENT BUILD ---------- */

function createEventFromData(titleText, timeData, dayOffset){
  const date = new Date();
  date.setDate(date.getDate() + dayOffset);

  let hour = timeData.hour;
  if(timeData.meridian === "pm" && hour !== 12) hour += 12;
  if(timeData.meridian === "am" && hour === 12) hour = 0;

  date.setHours(hour, timeData.minute, 0);
  const end = new Date(date.getTime() + 60 * 60 * 1000);

  const cleanTitle = titleText
    .replace(/\b(at\s*\d.*$)/,"")
    .replace(/\b\d{1,2}(:\d{2})?\s*(am|pm)\b/,"")
    .replace(/\btomorrow\b/,"")
    .trim() || "VoiceCal Event";

  pendingEvent = {
    summary: cleanTitle,
    start: {
      dateTime: date.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    },
    end: {
      dateTime: end.toISOString(),
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
    }
  };

  showConfirmation();
}

/* ---------- CONFIRMATION ---------- */

function showConfirmation(){
  mode = "confirm";
  cardDiv.style.display = "block";

  const readable = new Date(pendingEvent.start.dateTime).toLocaleString();

  cardDiv.innerHTML = `
    <b>Create Event?</b><br><br>
    ${pendingEvent.summary}<br>
    ${readable}<br><br>
    Say "yes" or "no"
  `;

  statusDiv.innerText = "Waiting for confirmation…";
  setTimeout(startListening, 600);
}

function handleConfirmation(text){
  if(text.includes("yes")){
    statusDiv.innerText = "Authorizing…";
    authorize();
  } else {
    reset();
  }
}

function reset(){
  cardDiv.style.display = "none";
  mode = "command";
  waitingForTime = false;
  setTimeout(startListening, 900);
}

/* ---------- GOOGLE AUTH ---------- */

function authorize(){
  gapi.load("client", async () => {
    await gapi.client.init({
      discoveryDocs:[
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"
      ]
    });

    const tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: async (resp) => {
        if(resp.error){
          statusDiv.innerText = "Authorization failed.";
          reset();
          return;
        }
        gapi.client.setToken(resp);
        await createEvent();
      }
    });

    tokenClient.requestAccessToken();
  });
}

async function createEvent(){
  try{
    await gapi.client.calendar.events.insert({
      calendarId: "primary",
      resource: pendingEvent
    });
    statusDiv.innerText = "Event created!";
  }catch(e){
    statusDiv.innerText = "Calendar error.";
  }
  reset();
}
</script>

</body>
</html>
