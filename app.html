<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VoiceCal v8.5</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>

<style>
body {
  margin:0;
  font-family: Arial, sans-serif;
  background:#111;
  color:#fff;
  text-align:center;
}

h1 { margin-top:20px; }

#micContainer {
  margin-top:20px;
  position:relative;
  display:inline-block;
}

#micButton {
  width:100px;
  cursor:pointer;
}

#ring {
  position:absolute;
  top:-12px;
  left:-12px;
  width:124px;
  height:124px;
  border-radius:50%;
  border:6px solid red;
  display:none;
}

#ring.active {
  display:block;
  animation:pulse 1s infinite;
}

@keyframes pulse {
  0% { transform:scale(1); opacity:1; }
  50% { transform:scale(1.1); opacity:0.6; }
  100% { transform:scale(1); opacity:1; }
}

#status {
  margin-top:20px;
  font-size:18px;
}

#card {
  margin:20px auto;
  padding:15px;
  background:#222;
  width:90%;
  max-width:400px;
  border-radius:10px;
  display:none;
}
button {
  padding:8px 16px;
  margin:5px;
  font-size:16px;
}
</style>
</head>

<body>

<h1>VoiceCal v8.5</h1>

<div id="micContainer">
  <div id="ring"></div>
  <img id="micButton" src="icon.png">
</div>

<div id="status">Tap mic to speak</div>

<div id="card"></div>

<script>
const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";
const API_KEY = "AIzaSyBmvb2xvKm0zagn20ZGYTE4nwQbHob-bso";

const DISCOVERY_DOC = "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

let tokenClient;
let gapiInited = false;
let gisInited = false;
let recognition;
let pendingEvent = null;
let confirmMode = false;

function gapiLoaded() {
  gapi.load("client", initializeGapiClient);
}

async function initializeGapiClient() {
  await gapi.client.init({
    apiKey: API_KEY,
    discoveryDocs: [DISCOVERY_DOC],
  });
  gapiInited = true;
}

function gisLoaded() {
  tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: SCOPES,
    callback: '',
  });
  gisInited = true;
}

gapiLoaded();
gisLoaded();

const micButton = document.getElementById("micButton");
const ring = document.getElementById("ring");
const status = document.getElementById("status");
const card = document.getElementById("card");

micButton.onclick = () => {
  if (confirmMode) return;
  startListening();
};

function startListening() {
  recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  recognition.lang = "en-US";
  recognition.start();
  ring.classList.add("active");
  status.innerText = "Listening...";

  recognition.onresult = (event) => {
    const text = event.results[0][0].transcript.toLowerCase();
    console.log("Heard:", text);
    ring.classList.remove("active");
    recognition.stop();

    if (confirmMode) {
      handleConfirmation(text);
    } else {
      handleCommand(text);
    }
  };

  recognition.onerror = () => {
    ring.classList.remove("active");
    status.innerText = "Error listening.";
  };
}

function handleConfirmation(text) {
  confirmMode = false;
  if (text.includes("yes")) {
    createEvent();
  } else {
    status.innerText = "Cancelled.";
    card.style.display = "none";
  }
}

function handleCommand(text) {

  if (text.startsWith("breakfast") ||
      text.startsWith("lunch") ||
      text.startsWith("dinner") ||
      text.startsWith("snack")) {
      createMealEvent(text);
      return;
  }

  let date = new Date();
  if (text.includes("tomorrow")) {
    date.setDate(date.getDate() + 1);
  }

  let timeMatch = text.match(/(\d{1,2})(?::(\d{2}))?\s*(a\.?m\.?|p\.?m\.?)/);
  if (!timeMatch) {
    if (text.includes("noon")) {
      date.setHours(12,0,0,0);
    } else if (text.includes("midnight")) {
      date.setHours(0,0,0,0);
    } else {
      status.innerText = "Please include a time.";
      return;
    }
  } else {
    let hour = parseInt(timeMatch[1]);
    let minute = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
    let meridian = timeMatch[3];

    if (meridian.startsWith("p") && hour < 12) hour += 12;
    if (meridian.startsWith("a") && hour === 12) hour = 0;

    date.setHours(hour, minute, 0, 0);
  }

  let end = new Date(date.getTime() + 60*60*1000);

  pendingEvent = {
    summary: text,
    start: { dateTime: date.toISOString() },
    end: { dateTime: end.toISOString() },
    reminders: {
      useDefault: false,
      overrides: [{ method: "popup", minutes: 30 }]
    }
  };

  showCard();
}

function createMealEvent(text) {
  let now = new Date();
  let end = new Date(now.getTime() + 30*60*1000);

  pendingEvent = {
    summary: text.toUpperCase(),
    start: { dateTime: now.toISOString() },
    end: { dateTime: end.toISOString() }
  };

  showCard();
}

function showCard() {
  card.style.display = "block";
  card.innerHTML = `
    <p>Create this event?</p>
    <p>${pendingEvent.summary}</p>
    <button onclick="confirmYes()">Yes</button>
    <button onclick="confirmNo()">No</button>
  `;
  confirmMode = true;
  status.innerText = "Say YES or NO";
  startListening();
}

function confirmYes() {
  confirmMode = false;
  createEvent();
}

function confirmNo() {
  confirmMode = false;
  card.style.display = "none";
  status.innerText = "Cancelled.";
}

function createEvent() {
  if (!gapi.client.getToken()) {
    tokenClient.callback = async (resp) => {
      await gapi.client.calendar.events.insert({
        calendarId: "primary",
        resource: pendingEvent
      });
      finishCreate();
    };
    tokenClient.requestAccessToken();
  } else {
    gapi.client.calendar.events.insert({
      calendarId: "primary",
      resource: pendingEvent
    }).then(finishCreate);
  }
}

function finishCreate() {
  card.style.display = "none";
  status.innerText = "Event created!";
  pendingEvent = null;
}
</script>

</body>
</html>
