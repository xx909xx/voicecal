<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VoiceCal</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#4285f4">
<link rel="icon" href="/icon.png">

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f6f9;
  text-align: center;
  padding: 30px;
  margin: 0;
}

.container { max-width: 500px; margin: auto; }

.mic-button {
  width: 120px;
  height: 120px;
  margin: 30px auto;
  border-radius: 50%;
  background: white;
  box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

.recording {
  background: #ff4d4d;
  box-shadow: 0 0 25px rgba(255,0,0,0.6);
}

.card {
  background: white;
  padding: 15px;
  margin-top: 15px;
  border-radius: 12px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.08);
  text-align: left;
}

#status { margin-top: 20px; font-weight: bold; }
#syncStatus { margin-top: 10px; font-size: 14px; color: #666; }
</style>

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>
</head>

<body>

<div class="container">
  <h1>VoiceCal</h1>
  <p>Version 4.3</p>

  <div class="mic-button" id="micBtn" onclick="startListening()">
    ðŸŽ¤
  </div>

  <div class="card" id="transcriptCard" style="display:none;">
    <strong>You said:</strong>
    <div id="transcript"></div>
  </div>

  <div id="status">Ready.</div>
  <div id="syncStatus"></div>
</div>

<script>
const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";
const API_KEY = "AIzaSyBmvb2xvKm0zagn20ZGYTE4nwQbHob-bso";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

let tokenClient;
let pendingEvent = null;
let recognition;

/* ================= OFFLINE QUEUE ================= */

function getQueue() {
  return JSON.parse(localStorage.getItem("eventQueue") || "[]");
}

function saveQueue(queue) {
  localStorage.setItem("eventQueue", JSON.stringify(queue));
  updateSyncStatus();
}

function addToQueue(event) {
  const queue = getQueue();
  queue.push(event);
  saveQueue(queue);
}

function updateSyncStatus() {
  const queue = getQueue();
  const el = document.getElementById("syncStatus");
  if (queue.length > 0) {
    el.innerText = `${queue.length} event(s) waiting to sync`;
  } else {
    el.innerText = "All events synced";
  }
}

/* ================= AUTO SYNC ================= */

async function syncQueue() {
  const queue = getQueue();
  if (queue.length === 0) return;

  if (!navigator.onLine) return;

  setStatus("Syncing offline events...");

  for (let event of queue) {
    try {
      await gapi.client.calendar.events.insert({
        calendarId: "primary",
        resource: event
      });
    } catch {
      return; // stop if one fails
    }
  }

  saveQueue([]);
  setStatus("All offline events synced!");
}

window.addEventListener("online", syncQueue);

/* ================= GOOGLE ================= */

function initGapi() {
  gapi.load("client", async () => {
    await gapi.client.init({
      apiKey: API_KEY,
      discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
    });
  });
}

function initGIS() {
  function wait() {
    if (!window.google?.accounts?.oauth2) {
      setTimeout(wait, 100);
      return;
    }
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: handleTokenResponse,
    });
  }
  wait();
}

async function handleTokenResponse(resp) {
  if (resp.error) return;

  gapi.client.setToken({ access_token: resp.access_token });

  if (!navigator.onLine) {
    addToQueue(pendingEvent);
    setStatus("Saved offline. Will sync automatically.");
    return;
  }

  try {
    await gapi.client.calendar.events.insert({
      calendarId: "primary",
      resource: pendingEvent
    });
    setStatus("Event created!");
    syncQueue();
  } catch {
    addToQueue(pendingEvent);
    setStatus("Saved offline due to error.");
  }
}

/* ================= VOICE ================= */

function startListening() {
  const mic = document.getElementById("micBtn");

  if (!('webkitSpeechRecognition' in window)) {
    alert("Speech recognition not supported.");
    return;
  }

  recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-US';
  recognition.continuous = false;

  mic.classList.add("recording");
  setStatus("Listening...");
  recognition.start();

  recognition.onresult = e => {
    const text = e.results[0][0].transcript;
    document.getElementById("transcript").innerText = text;
    document.getElementById("transcriptCard").style.display = "block";

    if (text.toLowerCase().includes("never mind")) {
      setStatus("Cancelled.");
      mic.classList.remove("recording");
      return;
    }

    parseText(text);
  };

  recognition.onend = () => {
    mic.classList.remove("recording");
  };
}

/* ================= SIMPLE PARSER ================= */

function parseText(text) {
  const now = new Date();
  now.setHours(now.getHours() + 1);

  const end = new Date(now.getTime() + 60 * 60 * 1000);

  pendingEvent = {
    summary: text,
    start: { dateTime: now.toISOString() },
    end: { dateTime: end.toISOString() }
  };

  tokenClient.requestAccessToken({
    prompt: gapi.client.getToken() ? "" : "consent"
  });
}

/* ================= INIT ================= */

initGapi();
initGIS();
updateSyncStatus();
syncQueue();
</script>

</body>
</html>
