<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>VoiceCal</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!--
VoiceCal v3.1
Build Date: 2026-02-20
Fix: submitEvent() renamed (avoids DOM createEvent conflict)
Added: Improved time parsing
-->

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f6f9;
  text-align: center;
  padding: 30px;
}

.container {
  max-width: 500px;
  margin: auto;
}

button {
  padding: 12px 18px;
  margin: 8px;
  font-size: 16px;
  border: none;
  border-radius: 8px;
  background: #4285f4;
  color: white;
  cursor: pointer;
}

button.secondary {
  background: #34a853;
}

button:disabled {
  background: #aaa;
}

.card {
  background: white;
  padding: 15px;
  margin-top: 15px;
  border-radius: 10px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.1);
  text-align: left;
}

#status {
  margin-top: 15px;
  font-weight: bold;
}
</style>

<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>

</head>
<body>

<div class="container">

<h1>VoiceCal</h1>
<p>Version 3.1 (2026-02-20)</p>

<button onclick="startListening()">üé§ Speak</button>

<div class="card" id="transcriptCard" style="display:none;">
  <strong>You said:</strong>
  <div id="transcript"></div>
</div>

<div class="card" id="previewCard" style="display:none;">
  <strong>Event Preview:</strong>
  <div id="preview"></div>
  <button class="secondary" onclick="submitEvent()">Create Event</button>
</div>

<div id="status">Ready.</div>

</div>

<script>
const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";
const API_KEY = "AIzaSyBmvb2xvKm0zagn20ZGYTE4nwQbHob-bso";
const SCOPES = "https://www.googleapis.com/auth/calendar.events";

let tokenClient;
let gapiReady = false;
let gisReady = false;
let pendingEvent = null;

/* ---------- Google Init ---------- */

function setStatus(msg) {
  document.getElementById("status").innerText = msg;
}

function initGapi() {
  gapi.load("client", async () => {
    await gapi.client.init({
      apiKey: API_KEY,
      discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"],
    });
    gapiReady = true;
  });
}

function initGIS() {
  function wait() {
    if (!window.google || !google.accounts || !google.accounts.oauth2) {
      setTimeout(wait, 100);
      return;
    }
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: handleTokenResponse,
    });
    gisReady = true;
  }
  wait();
}

async function handleTokenResponse(resp) {
  if (resp.error) {
    setStatus("Authentication failed.");
    return;
  }

  gapi.client.setToken({ access_token: resp.access_token });

  try {
    setStatus("Creating event...");
    await gapi.client.calendar.events.insert({
      calendarId: "primary",
      resource: pendingEvent
    });
    setStatus("‚úÖ Event created successfully!");
  } catch (err) {
    console.error(err);
    setStatus("‚ùå Failed to create event.");
  }
}

/* ---------- Voice Recognition ---------- */

let recognition;

function startListening() {
  if (!('webkitSpeechRecognition' in window)) {
    alert("Speech recognition not supported in this browser.");
    return;
  }

  recognition = new webkitSpeechRecognition();
  recognition.lang = 'en-US';
  recognition.start();

  setStatus("Listening...");

  recognition.onresult = function(event) {
    const text = event.results[0][0].transcript;
    document.getElementById("transcript").innerText = text;
    document.getElementById("transcriptCard").style.display = "block";
    parseText(text);
  };

  recognition.onerror = function() {
    setStatus("Speech recognition error.");
  };
}

/* ---------- Basic NLP ---------- */

function parseText(text) {
  const now = new Date();
  let date = new Date(now);

  const lower = text.toLowerCase();

  if (lower.includes("tomorrow")) {
    date.setDate(now.getDate() + 1);
  }

  // Normalize a.m./p.m.
  const cleaned = lower.replace(/a\.m\./g, "am").replace(/p\.m\./g, "pm");

  const timeMatch = cleaned.match(/(\d{1,2})(?::(\d{2}))?\s?(am|pm)?/);

  if (timeMatch) {
    let hour = parseInt(timeMatch[1]);
    let minute = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
    const ampm = timeMatch[3];

    if (ampm === "pm" && hour < 12) hour += 12;
    if (ampm === "am" && hour === 12) hour = 0;

    date.setHours(hour, minute, 0, 0);
  } else {
    date.setHours(9, 0, 0, 0);
  }

  const end = new Date(date.getTime() + 60 * 60 * 1000);

  pendingEvent = {
    summary: text,
    start: { dateTime: date.toISOString() },
    end: { dateTime: end.toISOString() }
  };

  document.getElementById("preview").innerHTML =
    `<strong>${text}</strong><br>
     ${date.toLocaleString()} ‚Äì ${end.toLocaleString()}`;

  document.getElementById("previewCard").style.display = "block";
  setStatus("Review and create event.");
}

/* ---------- Submit Event ---------- */

function submitEvent() {
  if (!gapiReady || !gisReady) {
    setStatus("Google API not ready.");
    return;
  }

  setStatus("Authenticating...");

  tokenClient.requestAccessToken({
    prompt: gapi.client.getToken() ? "" : "consent"
  });
}

initGapi();
initGIS();

</script>

</body>
</html>
