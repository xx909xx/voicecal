<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>VoiceCal</title>

<script src="https://accounts.google.com/gsi/client" async defer></script>

<style>
body {
  font-family: Arial, sans-serif;
  background: #111;
  color: white;
  text-align: center;
  margin-top: 80px;
}

#micButton {
  width: 180px;
  height: 180px;
  border-radius: 50%;
  border: none;
  background: #222;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: auto;
  position: relative;
  cursor: pointer;
}

#micButton img { width: 90px; }

#ring {
  position: absolute;
  width: 220px;
  height: 220px;
  border-radius: 50%;
  border: 6px solid red;
  opacity: 0;
}

.pulse {
  animation: pulse 1.2s infinite;
  opacity: 1 !important;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 0.6; }
  50% { transform: scale(1.15); opacity: 1; }
  100% { transform: scale(1); opacity: 0.6; }
}

#status {
  margin-top: 30px;
  font-size: 18px;
}
</style>
</head>
<body>

<h2>VoiceCal</h2>

<button id="micButton">
  <div id="ring"></div>
  <img src="/icon.png" />
</button>

<p id="status">Tap mic to speak</p>

<script>
const CLIENT_ID = "630726897821-4m33kk0js2fefdn102j6mumc1cooih49.apps.googleusercontent.com";

let accessToken = null;
let recognition;
let silenceTimer;

window.onload = () => {

  const tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: CLIENT_ID,
    scope: "https://www.googleapis.com/auth/calendar.events",
    callback: (response) => {
      if (response.access_token) {
        accessToken = response.access_token;
        document.getElementById("status").innerText = "Signed in. Ready.";
      }
    },
  });

  tokenClient.requestAccessToken();

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.lang = "en-US";
  recognition.continuous = false;
  recognition.interimResults = false;

  recognition.onstart = () => {
    document.getElementById("ring").classList.add("pulse");
    document.getElementById("status").innerText = "Listening...";
    navigator.vibrate?.(100);
  };

  recognition.onend = () => {
    document.getElementById("ring").classList.remove("pulse");
  };

  recognition.onresult = (event) => {
    clearTimeout(silenceTimer);
    const transcript = event.results[0][0].transcript;
    document.getElementById("status").innerText = "Heard: " + transcript;
    processText(transcript);
  };

  document.getElementById("micButton").onclick = () => {
    if (!accessToken) {
      tokenClient.requestAccessToken();
      return;
    }
    recognition.start();
    silenceTimer = setTimeout(() => recognition.stop(), 6000);
  };
};

/* ---------- TIME PARSING ---------- */

function parseTime(text) {
  const lower = text.toLowerCase()
    .replace(/p\.?\s?m\.?/g, "pm")
    .replace(/a\.?\s?m\.?/g, "am");

  const match = lower.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)/);
  if (!match) return null;

  let hour = parseInt(match[1]);
  let minute = match[2] ? parseInt(match[2]) : 0;
  const period = match[3];

  if (period === "pm" && hour < 12) hour += 12;
  if (period === "am" && hour === 12) hour = 0;

  const now = new Date();
  let year = now.getFullYear();
  let month = now.getMonth();
  let day = now.getDate();

  if (lower.includes("tomorrow")) {
    day += 1;
  }

  return new Date(year, month, day, hour, minute, 0, 0);
}

/* ---------- FORMAT LOCAL TIMEZONE (CST SAFE) ---------- */

function formatLocal(date) {
  const pad = (n) => n.toString().padStart(2, "0");

  const offset = -date.getTimezoneOffset();
  const sign = offset >= 0 ? "+" : "-";
  const abs = Math.abs(offset);
  const offsetH = pad(Math.floor(abs / 60));
  const offsetM = pad(abs % 60);

  return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}:00${sign}${offsetH}:${offsetM}`;
}

/* ---------- TEXT PROCESSING ---------- */

function processText(text) {

  // Prompt for Cheri correction
  if (/\bsherr?y\b/i.test(text)) {
    if (confirm("Did you mean Cheri?")) {
      text = text.replace(/\bsherr?y\b/gi, "Cheri");
    }
  }

  // Capitalize name after "with"
  text = text.replace(/with\s+([a-z]+)/gi, function(match, name) {
    return "with " + name.charAt(0).toUpperCase() + name.slice(1);
  });

  createEvent(text);
}

/* ---------- CREATE CALENDAR EVENT ---------- */

function createEvent(text) {

  const start = parseTime(text);

  if (!start) {
    document.getElementById("status").innerText =
      "Couldn't detect time from: " + text;
    return;
  }

  const end = new Date(start.getTime() + 30 * 60000);

  const event = {
    summary: text,
    start: { dateTime: formatLocal(start) },
    end: { dateTime: formatLocal(end) },
    reminders: {
      useDefault: false,
      overrides: [{ method: "popup", minutes: 30 }]
    }
  };

  fetch("https://www.googleapis.com/calendar/v3/calendars/primary/events", {
    method: "POST",
    headers: {
      Authorization: "Bearer " + accessToken,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(event)
  })
  .then(res => res.json())
  .then(data => {
    if (data.id) {
      document.getElementById("status").innerText = "Event added!";
      navigator.vibrate?.([100,50,100]);
    } else {
      document.getElementById("status").innerText = "Calendar error.";
      console.log(data);
    }
  });
}
</script>

</body>
</html>
